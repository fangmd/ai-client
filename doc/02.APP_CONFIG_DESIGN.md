# 应用配置功能设计方案

## 一、概述

实现应用配置的持久化存储和管理功能，包括主题设置等应用级别的配置数据。配置数据存储在 SQLite 数据库中，通过 IPC 通信实现主进程和渲染进程的数据同步。

## 二、数据库设计

### 2.1 数据模型

采用简洁的 Key-Value 结构存储配置。

#### Config（配置表）

```prisma
model Config {
  key       String   @id       // 配置键（唯一标识）
  value     String             // 配置值（JSON 字符串）
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("config")
}
```

**设计说明**：
- 使用 `key` 作为主键，保证配置项唯一性
- `value` 存储为 JSON 字符串，支持各种数据类型
- 简洁设计，无需 type 和 group 字段

### 2.2 预定义配置项

| Key | Default | Description |
|-----|---------|-------------|
| `theme` | `"system"` | 主题模式: light, dark, system |

## 三、架构设计

### 3.1 分层架构

```
┌─────────────────────────────────────────┐
│      Renderer 层 (UI)                   │
│  - Settings 组件                         │
│  - configStore (Zustand)                 │
└──────────────┬──────────────────────────┘
               │ IPC 通信
┌──────────────▼──────────────────────────┐
│      IPC 层 (通信桥梁)                   │
│  - IPC_CHANNELS.config.*                 │
│  - IPC 类型定义                          │
└──────────────┬──────────────────────────┘
               │ IPC 调用
┌──────────────▼──────────────────────────┐
│      Main Handler 层                    │
│  - ConfigHandler                        │
│  - 请求路由和分发                        │
└──────────────┬──────────────────────────┘
               │ 调用
┌──────────────▼──────────────────────────┐
│      Repository 层                       │
│  - config.ts                             │
│  - 数据访问和业务逻辑                     │
└──────────────┬──────────────────────────┘
               │ Prisma ORM
┌──────────────▼──────────────────────────┐
│      Database 层                        │
│  - SQLite                                │
└─────────────────────────────────────────┘
```

### 3.2 设计模式

1. **Repository 模式**
   - 封装数据访问逻辑
   - 提供统一的配置操作接口

2. **Handler 模式**
   - 统一处理 IPC 请求
   - 参数验证和错误处理
   - 响应格式化

3. **默认值策略**
   - 配置项不存在时返回默认值

## 四、核心功能设计

### 4.1 配置管理

#### 4.1.1 获取单个配置

**功能**：根据 key 获取配置值

**流程**：
1. 前端调用 IPC: `config:get`
2. Handler 查询数据库
3. 如果配置不存在，返回 null（前端使用默认值）
4. 返回配置值

**接口定义**：
```typescript
// IPC Request
{
  key: string
}

// IPC Response
{
  code: 0 | -1
  data: {
    key: string
    value: string  // JSON 字符串
  } | null
  msg: string
}
```

#### 4.1.2 获取所有配置

**功能**：获取所有配置项

**流程**：
1. 应用启动时调用
2. 前端调用 IPC: `config:getAll`
3. Handler 查询所有配置
4. 返回配置列表
5. 前端初始化 configStore

**接口定义**：
```typescript
// IPC Response
{
  code: 0 | -1
  data: Record<string, string>  // key-value 对象
  msg: string
}
```

#### 4.1.3 设置配置

**功能**：设置单个配置项

**流程**：
1. 用户修改设置
2. 前端调用 IPC: `config:set`
3. Handler 使用 upsert 更新或创建配置
4. 返回更新后的配置
5. 前端更新 configStore 和 UI

**接口定义**：
```typescript
// IPC Request
{
  key: string
  value: string  // JSON 字符串
}

// IPC Response
{
  code: 0 | -1
  data: {
    key: string
    value: string
  }
  msg: string
}
```

#### 4.1.4 删除配置

**功能**：删除配置项（恢复默认值）

**流程**：
1. 前端调用 IPC: `config:delete`
2. Handler 删除配置记录
3. 配置恢复为默认值

**接口定义**：
```typescript
// IPC Request
{
  key: string
}

// IPC Response
{
  code: 0 | -1
  msg: string
}
```

## 五、目录结构

```
src/
├── main/
│   ├── handlers/
│   │   └── config-handler.ts        # 配置 IPC Handler
│   └── repository/
│       └── config.ts                # 配置 Repository
├── common/
│   └── constants/
│       └── ipc.ts                   # IPC 通道常量（扩展）
└── types/
    ├── index.ts                     # 类型导出（扩展）
    └── config-type.ts               # 配置类型定义
```

## 六、IPC 通道定义

### 6.1 扩展 IPC_CHANNELS

```typescript
export const IPC_CHANNELS = {
  // ... 现有通道
  // Config 模块
  config: {
    get: 'config:get',
    getAll: 'config:get-all',
    set: 'config:set',
    delete: 'config:delete'
  }
} as const
```

### 6.2 IPC 类型定义

```typescript
interface ConfigIPC {
  get: {
    request: { key: string }
    response: IPCResponse<ConfigItem | null>
  }
  getAll: {
    request: void
    response: IPCResponse<Record<string, string>>
  }
  set: {
    request: {
      key: string
      value: string
    }
    response: IPCResponse<ConfigItem>
  }
  delete: {
    request: { key: string }
    response: IPCResponse<void>
  }
}
```

## 七、类型定义

### 7.1 配置类型

```typescript
// src/types/config-type.ts

/** 配置项 */
export interface ConfigItem {
  key: string
  value: string
  createdAt?: Date
  updatedAt?: Date
}

/** 主题模式 */
export type ThemeMode = 'light' | 'dark' | 'system'

/** 配置键常量 */
export const CONFIG_KEYS = {
  THEME: 'theme'
} as const

/** 默认配置 */
export const DEFAULT_CONFIG = {
  [CONFIG_KEYS.THEME]: 'system' as ThemeMode
} as const
```

## 八、Repository 层设计

### 8.1 Config Repository

```typescript
// src/main/repository/config.ts

/**
 * 获取单个配置
 */
export async function getConfig(key: string): Promise<ConfigItem | null>

/**
 * 获取配置值（带默认值）
 */
export async function getConfigValue<T>(key: string, defaultValue: T): Promise<T>

/**
 * 获取所有配置
 */
export async function getAllConfigs(): Promise<Record<string, string>>

/**
 * 设置配置
 */
export async function setConfig(key: string, value: string): Promise<ConfigItem>

/**
 * 删除配置
 */
export async function deleteConfig(key: string): Promise<void>
```

## 九、前端 Store 设计

### 9.1 configStore

```typescript
// src/renderer/src/stores/configStore.ts

interface ConfigState {
  // 配置数据
  theme: ThemeMode
  
  // Actions
  loadConfig: () => Promise<void>
  setTheme: (mode: ThemeMode) => Promise<void>
}
```

### 9.2 数据同步策略

1. **启动时加载**：应用启动时加载所有配置
2. **实时同步**：配置变更立即同步到数据库
3. **本地缓存**：使用 Zustand 作为本地缓存
4. **默认值回退**：配置不存在时使用默认值

## 十、与现有主题系统集成

### 10.1 改造 ThemeProvider

当前项目已有 `theme-provider.tsx`，需要改造以使用数据库配置：

```typescript
// 改造后的 ThemeProvider
export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  const { theme, loadConfig } = useConfigStore()
  
  useEffect(() => {
    loadConfig()
  }, [])
  
  return (
    <ThemeProviderPrimitive
      {...props}
      defaultTheme={theme}
      storageKey="ai-client-theme" // 保持向后兼容
    >
      {children}
    </ThemeProviderPrimitive>
  )
}
```

### 10.2 主题切换流程

1. 用户在设置界面切换主题
2. 调用 `configStore.setTheme(mode)`
3. Store 调用 IPC 保存到数据库
4. 同时更新 ThemeProvider 的状态
5. UI 实时响应主题变化

## 十一、实现步骤

### 阶段一：数据库设计
1. ✅ 设计方案（当前步骤）
2. 更新 Prisma Schema
3. 创建数据库迁移
4. 运行迁移

### 阶段二：基础设施
5. 创建类型定义文件
6. 扩展 IPC 通道常量

### 阶段三：Repository 层
7. 实现 Config Repository

### 阶段四：Handler 层
8. 实现 ConfigHandler
9. 注册 IPC Handlers

### 阶段五：前端集成
10. 创建 configStore
11. 改造 ThemeProvider
12. 更新 Settings 组件

### 阶段六：测试和优化
13. 功能测试
14. 性能优化

## 十二、注意事项

1. **向后兼容**
   - 保持现有 localStorage 主题设置的兼容
   - 首次启动时可迁移旧配置到数据库

2. **类型安全**
   - 配置值的类型推断
   - 编译时类型检查

3. **错误处理**
   - 配置读取失败时使用默认值
   - 保存失败时提示用户

4. **代码质量**
   - 遵循现有代码风格
   - 保持代码简洁易懂
   - 最小化修改范围

## 十三、扩展功能（未来）

1. **更多配置项**
   - 语言设置
   - 字体大小
   - 其他外观配置

2. **配置导入/导出**
   - 导出配置到 JSON 文件
   - 从文件导入配置
