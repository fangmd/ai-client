# 文件上传功能设计方案

## 一、功能概述

为聊天功能增加文件上传支持，允许用户在发送消息时附带图片等文件，实现多模态对话能力。

### 1.1 功能范围

**第一期（本次实现）：**
- 图片上传：`jpg`, `jpeg`, `png`, `gif`, `webp`
- OpenAI Vision API 支持

**后续扩展：**
- PDF、文档等需要文本提取的文件
- 拖拽上传、剪贴板粘贴

### 1.2 限制与约束

| 约束项 | 限制值 | 说明 |
|-------|--------|-----|
| 单个文件大小 | ≤ 20MB | OpenAI API 限制 |
| 单条消息附件数 | ≤ 10 个 | 避免过多附件 |
| 图片格式 | jpg/jpeg/png/gif/webp | OpenAI Vision 支持的格式 |
| 存储方式 | Base64 内嵌 | 简单实现，无需文件管理 |

## 二、架构设计

### 2.1 数据流

```
┌─────────────────────────────────────────────────────────────────┐
│                        Renderer (前端)                           │
├─────────────────────────────────────────────────────────────────┤
│  ChatInput                                                       │
│  ├── 文件选择按钮 (Paperclip Icon)                                │
│  ├── 已选文件预览列表 (可删除)                                     │
│  └── 发送时携带 attachments                                       │
├─────────────────────────────────────────────────────────────────┤
│  ChatStore                                                       │
│  └── Message.attachments: Attachment[]                           │
├─────────────────────────────────────────────────────────────────┤
│  MessageItem                                                     │
│  └── 显示消息中的图片附件                                          │
└────────────────────────────┬────────────────────────────────────┘
                             │ IPC (ai:stream-chat)
                             │ attachments 随消息传递
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                        Main (主进程)                             │
├─────────────────────────────────────────────────────────────────┤
│  AIHandler                                                       │
│  └── 接收 attachments，传递给 Provider                            │
├─────────────────────────────────────────────────────────────────┤
│  OpenAIProvider                                                  │
│  └── 构建 OpenAI Vision 格式的 messages                          │
│      content: [                                                  │
│        { type: "text", text: "..." },                           │
│        { type: "image_url", image_url: { url: "data:..." } }    │
│      ]                                                           │
├─────────────────────────────────────────────────────────────────┤
│  MessageRepository                                               │
│  └── 存取 attachments (JSON 序列化)                               │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 设计原则

1. **最小改动**：只修改必要的文件，不引入新模块
2. **类型安全**：通过 TypeScript 类型约束数据流
3. **可扩展**：Attachment 类型设计考虑后续支持更多文件类型
4. **向后兼容**：不影响现有无附件消息的功能

## 三、类型定义

### 3.1 Attachment 类型

```typescript
// src/types/chat-type.ts

/**
 * 附件类型
 */
export type AttachmentType = 'image' | 'file'

/**
 * 附件数据
 */
export interface Attachment {
  id: bigint              // 唯一标识 (snowflake)
  type: AttachmentType    // 附件类型
  name: string            // 文件名
  mimeType: string        // MIME 类型 (e.g., 'image/png')
  size: number            // 文件大小 (bytes)
  data: string            // Base64 编码的文件内容
}
```

### 3.2 Message 类型更新

```typescript
// 前端消息类型
export interface Message {
  id: bigint
  role: MessageRole
  content: string
  timestamp: number
  status?: MessageStatus
  attachments?: Attachment[]  // 新增：附件列表
}

// 数据库消息类型
export type DbMessage = {
  id: bigint
  sessionId: bigint
  role: string
  content: string
  attachments: string | null  // 新增：JSON 字符串存储
  status: string | null
  totalTokens: number | null
  createdAt: Date
}

// 消息创建数据
export type CreateMessageData = {
  sessionId: bigint
  role: MessageRole
  content: string
  attachments?: Attachment[]  // 新增
  status?: DbMessageStatus
  totalTokens?: number
}
```

## 四、数据库变更

### 4.1 Schema 更新

采用独立表存储附件，避免 base64 数据膨胀 Message 表：

```prisma
// prisma/schema.prisma

model Message {
  id          BigInt   @id
  sessionId   BigInt
  role        String
  content     String
  status      String?
  totalTokens Int?
  createdAt   DateTime @default(now())

  @@index([sessionId])
  @@index([createdAt])
  @@map("message")
}

model Attachment {
  id        BigInt   @id
  messageId BigInt   // 所属消息 ID（逻辑外键）
  type      String   // 类型: image, file
  name      String   // 文件名
  mimeType  String   // MIME 类型
  size      Int      // 文件大小 (bytes)
  data      String   // Base64 编码的文件内容
  createdAt DateTime @default(now())

  @@index([messageId])
  @@map("attachment")
}
```

### 4.2 设计说明

**为什么使用独立表而非 JSON 字段？**

1. **避免数据膨胀**：base64 数据很大，存在 JSON 字段会导致 Message 表急剧膨胀
2. **查询效率**：独立表可单独索引和查询，不影响消息列表性能
3. **数据复用**：未来可支持附件去重、跨消息引用等功能
4. **清晰分离**：关注点分离，附件管理与消息管理解耦

## 五、组件设计

### 5.1 ChatInput 组件

**新增功能：**
- 文件选择按钮（回形针图标）
- 已选文件预览区域（支持删除）
- 发送时携带 attachments

**Props 变更：**
```typescript
interface Props {
  // ... 现有 props
  onSend: (content: string, attachments?: Attachment[]) => void  // 更新签名
}
```

**内部状态：**
```typescript
const [attachments, setAttachments] = useState<Attachment[]>([])
```

**文件选择逻辑：**
```typescript
import { generateUUID } from '@/common/snowflake'

const handleFileSelect = async (e: ChangeEvent<HTMLInputElement>) => {
  const files = Array.from(e.target.files || [])
  
  for (const file of files) {
    // 验证文件类型和大小
    if (!ALLOWED_IMAGE_TYPES.includes(file.type)) continue
    if (file.size > MAX_FILE_SIZE) continue
    if (attachments.length >= MAX_ATTACHMENTS) break
    
    // 读取为 Base64
    const data = await readFileAsBase64(file)
    
    const attachment: Attachment = {
      id: generateUUID() as bigint,
      type: 'image',
      name: file.name,
      mimeType: file.type,
      size: file.size,
      data
    }
    
    setAttachments(prev => [...prev, attachment])
  }
}
```

### 5.2 MessageItem 组件

**新增功能：**
- 显示消息中的图片附件
- 图片点击可放大预览（可选）

**渲染逻辑：**
```typescript
// 渲染附件
{message.attachments?.map((attachment) => (
  attachment.type === 'image' && (
    <img
      key={attachment.id}
      src={`data:${attachment.mimeType};base64,${attachment.data}`}
      alt={attachment.name}
      className="max-w-xs rounded-lg"
    />
  )
))}
```

### 5.3 文件预览组件

```typescript
// src/renderer/src/chat/attachment-preview.tsx

interface AttachmentPreviewProps {
  attachments: Attachment[]
  onRemove: (id: bigint) => void
}

export const AttachmentPreview: React.FC<AttachmentPreviewProps> = ({
  attachments,
  onRemove
}) => {
  if (attachments.length === 0) return null
  
  return (
    <div className="flex gap-2 flex-wrap p-2">
      {attachments.map((attachment) => (
        <div key={attachment.id} className="relative group">
          <img
            src={`data:${attachment.mimeType};base64,${attachment.data}`}
            alt={attachment.name}
            className="w-16 h-16 object-cover rounded"
          />
          <button
            onClick={() => onRemove(attachment.id)}
            className="absolute -top-2 -right-2 bg-destructive text-white rounded-full w-5 h-5"
          >
            ×
          </button>
        </div>
      ))}
    </div>
  )
}
```

## 六、主进程变更

### 6.1 AIHandler

**请求类型更新：**
```typescript
interface StreamChatRequest {
  messages: Array<{
    role: MessageRole
    content: string
    attachments?: Attachment[]  // 新增
  }>
  config: AIConfig
  requestId: string
}
```

**处理逻辑无需修改**，attachments 透传给 Provider。

### 6.2 OpenAIProvider

**核心变更：消息格式转换**

OpenAI Vision API 消息格式（官方文档）：
```json
{
  "role": "user",
  "content": [
    { "type": "text", "text": "What is in this image?" },
    {
      "type": "image_url",
      "image_url": {
        "url": "data:image/jpeg;base64,{BASE64_IMAGE}",
        "detail": "auto"
      }
    }
  ]
}
```

**`detail` 参数说明：**
- `low`：低分辨率处理，节省 token，加快响应
- `high`：高分辨率处理，适合需要细节分析的场景
- `auto`：（默认）自动选择

```typescript
// src/main/providers/openai-provider.ts

async streamChat(
  messages: Array<{ role: MessageRole; content: string; attachments?: Attachment[] }>,
  config: AIConfig,
  callbacks: { onChunk; onDone; onError },
  abortSignal?: AbortSignal
): Promise<void> {
  // ...
  
  // 转换消息格式
  const openaiMessages = messages.map((msg) => {
    const hasImageAttachments = msg.attachments?.some(a => a.type === 'image')
    
    // 有图片附件时，使用 Vision 格式
    if (hasImageAttachments) {
      const content: Array<
        | { type: 'text'; text: string }
        | { type: 'image_url'; image_url: { url: string; detail?: 'low' | 'high' | 'auto' } }
      > = []
      
      // 添加文本内容
      if (msg.content) {
        content.push({ type: 'text', text: msg.content })
      }
      
      // 添加图片
      msg.attachments
        ?.filter(a => a.type === 'image')
        .forEach(a => {
          content.push({
            type: 'image_url',
            image_url: {
              url: `data:${a.mimeType};base64,${a.data}`,
              detail: 'auto'  // 可配置
            }
          })
        })
      
      return { role: msg.role, content }
    }
    
    // 无附件，使用普通格式
    return { role: msg.role, content: msg.content }
  })
  
  // ... 调用 API
}
```

### 6.3 MessageRepository

**新增 attachments 字段处理：**

```typescript
// src/main/repository/message.ts
import { generateUUID } from '@/common/snowflake'

// 创建消息
async create(data: CreateMessageData): Promise<DbMessage> {
  return prisma.message.create({
    data: {
      id: generateUUID() as bigint,
      sessionId: data.sessionId,
      role: data.role,
      content: data.content,
      attachments: data.attachments ? JSON.stringify(data.attachments) : null,
      status: data.status || 'sent',
      totalTokens: data.totalTokens
    }
  })
}

// 查询时解析 attachments
async findBySessionId(sessionId: bigint): Promise<Message[]> {
  const messages = await prisma.message.findMany({
    where: { sessionId },
    orderBy: { createdAt: 'asc' }
  })
  
  return messages.map(msg => ({
    ...msg,
    attachments: msg.attachments ? JSON.parse(msg.attachments) : undefined
  }))
}
```

## 七、实现步骤

| 步骤 | 任务 | 影响文件 |
|-----|------|---------|
| 1 | 定义 Attachment 类型 | `src/types/chat-type.ts` |
| 2 | 数据库 migration | `prisma/schema.prisma`, migration |
| 3 | MessageRepository 支持 attachments | `src/main/repository/message.ts` |
| 4 | OpenAIProvider 支持 Vision 格式 | `src/main/providers/openai-provider.ts` |
| 5 | ChatStore 更新类型定义 | `src/renderer/src/stores/chatStore.ts` |
| 6 | ChatInput 添加文件上传 | `src/renderer/src/chat/chat-input.tsx` |
| 7 | 新增 AttachmentPreview 组件 | `src/renderer/src/chat/attachment-preview.tsx` |
| 8 | MessageItem 显示附件 | `src/renderer/src/chat/message-item.tsx` |
| 9 | 更新 IPC 类型定义 | `src/types/ipc-type.ts` |

## 八、常量定义

```typescript
// src/common/constants/file.ts

/** 允许的图片类型 */
export const ALLOWED_IMAGE_TYPES = [
  'image/jpeg',
  'image/jpg', 
  'image/png',
  'image/gif',
  'image/webp'
]

/** 最大文件大小 (20MB) */
export const MAX_FILE_SIZE = 20 * 1024 * 1024

/** 单条消息最大附件数 */
export const MAX_ATTACHMENTS = 10

/** 文件类型对应的 Accept 字符串 */
export const IMAGE_ACCEPT = 'image/jpeg,image/jpg,image/png,image/gif,image/webp'
```

## 九、工具函数

```typescript
// src/renderer/src/utils/file.ts

/**
 * 读取文件为 Base64
 */
export const readFileAsBase64 = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader()
    reader.onload = () => {
      const result = reader.result as string
      // 移除 data:xxx;base64, 前缀
      const base64 = result.split(',')[1]
      resolve(base64)
    }
    reader.onerror = reject
    reader.readAsDataURL(file)
  })
}

/**
 * 格式化文件大小
 */
export const formatFileSize = (bytes: number): string => {
  if (bytes < 1024) return `${bytes} B`
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`
}

/**
 * 验证文件是否为允许的图片类型
 */
export const isAllowedImageType = (mimeType: string): boolean => {
  return ALLOWED_IMAGE_TYPES.includes(mimeType)
}
```

## 十、后续扩展

### 10.1 文件存储优化

当前方案使用 Base64 内嵌存储，适合小文件。对于大文件或高频使用场景，可改为：

```
文件 → 本地文件系统存储 → 数据库存储文件路径
```

### 10.2 更多文件类型支持

| 文件类型 | 处理方式 |
|---------|---------|
| PDF | 提取文本内容作为 context |
| Word/Excel | 转换为文本或 Markdown |
| 代码文件 | 直接作为文本内容 |

### 10.3 交互增强

- **拖拽上传**：监听 drop 事件
- **剪贴板粘贴**：监听 paste 事件，处理图片数据
- **图片预览**：点击放大查看原图

