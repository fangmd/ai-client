# AI 对话管理功能设计方案

## 一、概述

实现 AI 对话的持久化存储和管理功能，包括对话的创建、查询、更新、删除，以及消息的存储和管理。对话数据存储在 SQLite 数据库中，通过 IPC 通信实现主进程和渲染进程的数据同步。

## 二、数据库设计

### 2.1 数据模型

#### ChatSession（对话会话表）

```prisma
model ChatSession {
  id          BigInt   @id
  title       String   // 对话标题
  aiProviderId BigInt  // 关联的 AI Provider ID（逻辑外键，必填）
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([aiProviderId])
  @@index([createdAt])
  @@index([updatedAt])
  @@map("chat_session")
}
```

#### Message（消息表）

```prisma
model Message {
  id          BigInt   @id
  sessionId   BigInt   // 所属会话 ID（逻辑外键）
  role        String   // 角色: user, assistant, system
  content     String   // 消息内容
  status      String?  // 状态: sent(已发送), pending(发送中), error(错误)
  totalTokens Int?     // Token 总数（可选）
  createdAt   DateTime @default(now())

  @@index([sessionId])
  @@index([createdAt])
  @@map("message")
}
```

**注意**：
- 使用逻辑外键，不在数据库层面定义物理外键约束
- `sessionId` 和 `aiProviderId` 仅作为普通字段存储，通过应用层维护关联关系
- `aiProviderId` 为必填字段，创建会话时必须指定
- 删除操作需要在应用层手动处理级联删除逻辑

### 2.2 数据库迁移

需要创建新的迁移文件来添加这两个表。

### 2.3 外键设计说明

**使用逻辑外键而非物理外键的原因**：
1. **灵活性**：逻辑外键提供更大的灵活性，不受数据库约束限制
2. **性能**：避免物理外键带来的性能开销和锁竞争
3. **迁移便利**：数据迁移和备份恢复更加简单
4. **控制权**：应用层完全控制关联关系的维护和级联删除逻辑

**实现方式**：
- `sessionId` 和 `aiProviderId` 作为普通 BigInt 字段存储
- 通过索引优化查询性能
- 在应用层（Repository 层）维护数据完整性
- 使用事务确保级联删除的原子性

## 三、架构设计

### 3.1 分层架构

```
┌─────────────────────────────────────────┐
│      Renderer 层 (UI)                   │
│  - ChatSessionList 组件                  │
│  - chatStore (Zustand)                   │
│  - 对话列表展示和管理                     │
└──────────────┬──────────────────────────┘
               │ IPC 通信
┌──────────────▼──────────────────────────┐
│      IPC 层 (通信桥梁)                   │
│  - IPC_CHANNELS.chatSession.*           │
│  - IPC 类型定义                          │
└──────────────┬──────────────────────────┘
               │ IPC 调用
┌──────────────▼──────────────────────────┐
│      Main Handler 层                    │
│  - ChatSessionHandler                   │
│  - 请求路由和分发                        │
└──────────────┬──────────────────────────┘
               │ 调用
┌──────────────▼──────────────────────────┐
│      Repository 层                       │
│  - chat-session.ts                      │
│  - message.ts                           │
│  - 数据访问和业务逻辑                     │
└──────────────┬──────────────────────────┘
               │ Prisma ORM
┌──────────────▼──────────────────────────┐
│      Database 层                        │
│  - SQLite                                │
└─────────────────────────────────────────┘
```

### 3.2 设计模式

1. **Repository 模式**
   - 封装数据访问逻辑
   - 提供统一的数据操作接口
   - 隔离数据库实现细节

2. **Handler 模式**
   - 统一处理 IPC 请求
   - 参数验证和错误处理
   - 响应格式化

3. **Store 模式（Zustand）**
   - 前端状态管理
   - 与数据库同步
   - 本地缓存优化

## 四、核心功能设计

### 4.1 对话会话管理

#### 4.1.1 创建对话

**功能**：创建新的对话会话

**触发时机**：用户发送第一条消息时自动创建对话（延迟创建策略）

**流程**：
1. 用户在输入框输入消息并发送
2. 前端检查当前是否有活跃的会话
3. 如果没有活跃会话，先调用 IPC: `chatSession:create` 创建新会话
4. Handler 验证 `aiProviderId` 有效性后创建新的 ChatSession 记录
5. 返回会话信息，前端更新 chatStore
6. 然后继续发送消息到 AI（创建 Message 记录）

**设计说明**：
- 采用延迟创建策略，避免创建空会话
- 用户点击"新建对话"按钮时，仅重置当前会话状态，不立即创建数据库记录
- 只有在发送第一条消息时才真正创建会话记录

**接口定义**：
```typescript
// IPC Request
{
  title?: string  // 可选，默认根据第一条消息生成
  aiProviderId: bigint  // 必填，关联的 AI Provider
}

// IPC Response
{
  code: 0 | -1
  data: ChatSession
  msg: string
}
```

#### 4.1.2 查询对话列表

**功能**：获取所有对话会话列表

**流程**：
1. 应用启动或刷新时调用
2. 前端调用 IPC: `chatSession:list`
3. Handler 查询数据库
4. 返回会话列表（按更新时间倒序）
5. 前端更新 chatStore

**接口定义**：
```typescript
// IPC Request
{
  limit?: number  // 可选，默认 100
  offset?: number  // 可选，默认 0
}

// IPC Response
{
  code: 0 | -1
  data: ChatSession[]
  msg: string
}
```

#### 4.1.3 查询单个对话

**功能**：根据 ID 获取对话详情（包含消息列表）

**流程**：
1. 用户点击对话列表项
2. 前端调用 IPC: `chatSession:get`
3. Handler 查询会话和关联的消息
4. 返回完整会话信息
5. 前端更新当前会话和消息列表

**接口定义**：
```typescript
// IPC Request
{
  id: bigint
}

// IPC Response
{
  code: 0 | -1
  data: ChatSession & { messages: Message[] }
  msg: string
}
```

#### 4.1.4 更新对话

**功能**：更新对话标题或其他信息

**流程**：
1. 用户修改对话标题
2. 前端调用 IPC: `chatSession:update`
3. Handler 更新数据库记录（仅更新标题，aiProviderId 不可修改）
4. 返回更新后的会话信息
5. 前端更新 chatStore

**注意**：`aiProviderId` 创建后不可修改。如需更换 AI Provider，应创建新的会话。

**接口定义**：
```typescript
// IPC Request
{
  id: bigint
  data: {
    title?: string
    // 注意：aiProviderId 创建后不可修改，如需更换 Provider 应创建新会话
  }
}

// IPC Response
{
  code: 0 | -1
  data: ChatSession
  msg: string
}
```

#### 4.1.5 删除对话

**功能**：删除对话及其所有消息

**流程**：
1. 用户点击删除按钮
2. 前端调用 IPC: `chatSession:delete`
3. Handler 调用 Repository 的 `deleteChatSession` 方法
4. Repository 层使用事务：先删除所有关联的消息，再删除会话
5. 返回删除结果
6. 前端更新 chatStore 和 UI

**接口定义**：
```typescript
// IPC Request
{
  id: bigint
}

// IPC Response
{
  code: 0 | -1
  msg: string
}
```

#### 4.1.6 搜索对话

**状态**：⚠️ 暂时不做

**功能**：根据关键词搜索对话标题或消息内容（未来功能）

**说明**：搜索功能将在后续版本中实现，当前版本暂不支持。

**接口定义**（预留，暂不实现）：
```typescript
// IPC Request
{
  keyword: string
  limit?: number
}

// IPC Response
{
  code: 0 | -1
  data: ChatSession[]
  msg: string
}
```

### 4.2 消息管理

#### 4.2.1 添加消息

**功能**：向对话中添加新消息

**流程**：
1. 用户发送消息时，检查当前是否有活跃会话
2. 如果没有活跃会话，先调用 `chatSession:create` 创建新会话
3. 创建用户消息记录，状态设置为 `pending`
4. 前端调用 IPC: `message:create`
5. Handler 创建消息记录
6. 更新会话的 updatedAt
7. 返回消息信息
8. 前端更新 chatStore
9. AI 回复时，创建 AI 消息记录，状态设置为 `pending`
10. 消息发送完成后，状态更新为 `sent`；如果失败，状态更新为 `error`

**接口定义**：
```typescript
// IPC Request
{
  sessionId: bigint
  role: 'user' | 'assistant' | 'system'
  content: string
  status?: 'sent' | 'pending' | 'error'
  totalTokens?: number  // Token 总数（可选）
}

// IPC Response
{
  code: 0 | -1
  data: Message
  msg: string
}
```

#### 4.2.2 更新消息

**功能**：更新消息内容或状态（用于流式响应）

**流程**：
1. AI 流式响应时，消息状态设置为 `pending`，逐块更新消息内容
2. 前端调用 IPC: `message:update` 追加内容
3. Handler 更新消息记录
4. 流式响应完成时，将状态更新为 `sent`，如果有 Token 统计信息，更新 `totalTokens` 字段
5. 如果发生错误，将状态更新为 `error`
6. 返回更新后的消息
7. 前端更新 chatStore

**状态说明**：
- `pending`: 消息正在发送中（流式响应进行中）
- `sent`: 消息已成功发送完成
- `error`: 消息发送失败

**注意**：`totalTokens` 通常在流式响应完成时从 AI Provider 的响应中获取并更新

**接口定义**：
```typescript
// IPC Request
{
  id: bigint
  data: {
    content?: string  // 追加内容
    status?: 'sent' | 'pending' | 'error'
    totalTokens?: number  // Token 总数（可选）
  }
}

// IPC Response
{
  code: 0 | -1
  data: Message
  msg: string
}
```

#### 4.2.3 查询消息列表

**功能**：获取对话的所有消息

**流程**：
1. 加载对话时自动调用
2. 前端调用 IPC: `message:list`
3. Handler 查询消息列表
4. 返回消息列表（按创建时间排序）
5. 前端更新消息显示

**接口定义**：
```typescript
// IPC Request
{
  sessionId: bigint
}

// IPC Response
{
  code: 0 | -1
  data: Message[]
  msg: string
}
```

### 4.3 对话标题自动生成

**功能**：根据第一条用户消息自动生成对话标题

**策略**：
1. 创建对话时，如果未提供标题，使用默认标题 "New Chat"
2. 当第一条用户消息发送后，自动生成标题
3. 标题生成规则：
   - 提取用户消息的前 30 个字符
   - 去除首尾空格和换行
   - 如果为空，使用 "New Chat"

**实现位置**：
- Repository 层的 `createMessage` 方法中
- 检查是否为会话的第一条用户消息
- 如果是，调用 `updateChatSession` 更新标题

## 五、目录结构

```
src/
├── main/
│   ├── handlers/
│   │   ├── chat-session-handler.ts    # 对话会话 IPC Handler
│   │   └── message-handler.ts         # 消息 IPC Handler
│   └── repository/
│       ├── chat-session.ts            # 对话会话 Repository
│       └── message.ts                 # 消息 Repository
├── common/
│   └── constants/
│       └── ipc.ts                     # IPC 通道常量（扩展）
├── preload/
│   └── types.ts                       # IPC 类型定义（扩展）
└── types/
    └── chat.ts                        # 类型定义（扩展）
```

## 六、IPC 通道定义

### 6.1 扩展 IPC_CHANNELS

```typescript
export const IPC_CHANNELS = {
  // ... 现有通道
  // Chat Session 模块
  chatSession: {
    create: 'chat-session:create',
    list: 'chat-session:list',
    get: 'chat-session:get',
    update: 'chat-session:update',
    delete: 'chat-session:delete',
    search: 'chat-session:search'  // 暂时不做
  },
  // Message 模块
  message: {
    create: 'message:create',
    update: 'message:update',
    list: 'message:list'
  }
} as const
```

### 6.2 IPC 类型定义

```typescript
interface ChatSessionIPC {
  create: {
    request: {
      title?: string
      aiProviderId: bigint  // 必填
    }
    response: IPCResponse<ChatSession>
  }
  list: {
    request: {
      limit?: number
      offset?: number
    }
    response: IPCResponse<ChatSession[]>
  }
  get: {
    request: { id: bigint }
    response: IPCResponse<ChatSession & { messages: Message[] }>
  }
  update: {
    request: {
      id: bigint
      data: {
        title?: string
        // 注意：aiProviderId 创建后不可修改
      }
    }
    response: IPCResponse<ChatSession>
  }
  delete: {
    request: { id: bigint }
    response: IPCResponse<void>
  }
  search: {
    // 暂时不做
    request: {
      keyword: string
      limit?: number
    }
    response: IPCResponse<ChatSession[]>
  }
}

interface MessageIPC {
  create: {
    request: {
      sessionId: bigint
      role: 'user' | 'assistant' | 'system'
      content: string
      status?: 'sent' | 'pending' | 'error'
      totalTokens?: number
    }
    response: IPCResponse<Message>
  }
  update: {
    request: {
      id: bigint
      data: {
        content?: string
        status?: 'sent' | 'pending' | 'error'
        totalTokens?: number
      }
    }
    response: IPCResponse<Message>
  }
  list: {
    request: { sessionId: bigint }
    response: IPCResponse<Message[]>
  }
}
```

## 七、Repository 层设计

### 7.1 ChatSession Repository

```typescript
// src/main/repository/chat-session.ts

/**
 * 创建对话会话
 */
export async function createChatSession(data: {
  title?: string
  aiProviderId: bigint  // 必填
}): Promise<ChatSession>

/**
 * 查询所有对话会话
 */
export async function listChatSessions(options?: {
  limit?: number
  offset?: number
}): Promise<ChatSession[]>

/**
 * 根据 ID 查询对话会话（包含消息）
 */
export async function getChatSessionById(id: bigint): Promise<ChatSession & { messages: Message[] } | null>

/**
 * 更新对话会话
 * 注意：aiProviderId 创建后不可修改，如需更换 Provider 应创建新会话
 */
export async function updateChatSession(
  id: bigint,
  data: { title?: string }
): Promise<ChatSession>

/**
 * 删除对话会话（应用层级联删除消息）
 * 注意：由于使用逻辑外键，需要在应用层手动删除关联的消息
 * 实现方式：先删除所有关联的消息，再删除会话（使用事务确保原子性）
 */
export async function deleteChatSession(id: bigint): Promise<void>

/**
 * 搜索对话会话
 * 注意：暂时不做，将在后续版本中实现
 */
export async function searchChatSessions(keyword: string, limit?: number): Promise<ChatSession[]>
```

### 7.2 Message Repository

```typescript
// src/main/repository/message.ts

/**
 * 创建消息
 */
export async function createMessage(data: {
  sessionId: bigint
  role: 'user' | 'assistant' | 'system'
  content: string
  status?: 'sent' | 'pending' | 'error'
  totalTokens?: number
}): Promise<Message>

/**
 * 更新消息
 */
export async function updateMessage(
  id: bigint,
  data: { content?: string; status?: 'sent' | 'pending' | 'error'; totalTokens?: number }
): Promise<Message>

/**
 * 追加消息内容（用于流式响应）
 */
export async function appendMessageContent(id: bigint, content: string): Promise<Message>

/**
 * 查询会话的所有消息
 */
export async function listMessages(sessionId: bigint): Promise<Message[]>

/**
 * 删除会话的所有消息（用于级联删除）
 */
export async function deleteMessagesBySessionId(sessionId: bigint): Promise<void>

/**
 * 检查是否为会话的第一条用户消息
 */
export async function isFirstUserMessage(sessionId: bigint): Promise<boolean>
```

## 八、前端 Store 改造

### 8.1 chatStore 扩展

需要将现有的内存存储改为与数据库同步：

```typescript
interface ChatState {
  // 当前会话
  currentSessionId: bigint | null
  sessions: ChatSession[]
  messages: Message[]

  // 加载状态
  loadingSessions: boolean
  loadingMessages: boolean

  // Actions - 同步数据库
  loadSessions: () => Promise<void>
  loadSession: (id: bigint) => Promise<void>
  createSession: (aiProviderId: bigint, title?: string) => Promise<bigint>  // 发送第一条消息时调用
  updateSession: (id: bigint, data: { title?: string }) => Promise<void>
  deleteSession: (id: bigint) => Promise<void>
  searchSessions: (keyword: string) => Promise<void>  // 暂时不做

  // Actions - 消息管理
  addMessage: (message: Omit<Message, 'id' | 'createdAt'>) => Promise<void>
  updateMessage: (id: bigint, updates: Partial<Message>) => Promise<void>
  appendToMessage: (id: bigint, content: string) => Promise<void>
  loadMessages: (sessionId: bigint) => Promise<void>
  
  // 注意：Message 类型需要包含 totalTokens 字段

  // Actions - 本地状态
  setCurrentSession: (sessionId: bigint | null) => void
  clearMessages: () => void
  resetChat: () => void  // 重置当前会话状态，准备新对话（不创建数据库记录）
}
```

### 8.2 数据同步策略

1. **启动时加载**：应用启动时加载所有会话列表
2. **懒加载消息**：切换会话时加载该会话的消息
3. **延迟创建会话**：用户发送第一条消息时才创建会话记录，避免空会话
4. **实时同步**：创建、更新、删除操作立即同步到数据库
5. **本地缓存**：使用 Zustand 作为本地缓存，减少数据库查询

## 九、UI 组件设计

### 9.1 ChatSessionList 组件

**位置**：`src/renderer/src/components/ChatSessionList.tsx`

**功能**：
- 显示对话列表
- 支持新建对话（重置当前会话状态，等待用户发送第一条消息时创建）
- 支持切换对话
- 支持删除对话
- ~~支持搜索对话~~（暂时不做）
- 显示对话标题和最后更新时间

**Props**：
```typescript
interface ChatSessionListProps {
  sessions: ChatSession[]
  currentSessionId: bigint | null
  onSelectSession: (id: bigint) => void
  onNewChat: () => void  // 重置当前会话状态，不立即创建数据库记录
  onDeleteSession: (id: bigint) => void
  onSearch?: (keyword: string) => void  // 暂时不做，可选属性
}
```

### 9.2 集成到 Home 组件

在 `home.tsx` 的侧边栏中集成 `ChatSessionList` 组件，替换现有的"添加对话"按钮。

## 十、实现步骤

### 阶段一：数据库设计
1. ✅ 设计方案（当前步骤）
2. 更新 Prisma Schema
3. 创建数据库迁移
4. 运行迁移

### 阶段二：Repository 层
5. 实现 ChatSession Repository
6. 实现 Message Repository
7. 编写单元测试（可选）

### 阶段三：Handler 层
8. 实现 ChatSessionHandler
9. 实现 MessageHandler
10. 注册 IPC Handlers

### 阶段四：IPC 层
11. 扩展 IPC_CHANNELS
12. 扩展 IPC 类型定义
13. 更新 Preload API

### 阶段五：前端改造
14. 改造 chatStore，集成数据库操作
15. 创建 ChatSessionList 组件
16. 集成到 Home 组件
17. 更新 Chat 组件，使用数据库存储

### 阶段六：功能完善
18. 实现对话标题自动生成
19. ~~实现搜索功能~~（暂时不做）
20. 优化加载性能
21. 错误处理和用户提示

### 阶段七：测试和优化
22. 功能测试
23. 性能优化
24. 代码审查和重构

## 十一、注意事项

1. **数据一致性**
   - 使用 Prisma 事务确保数据一致性
   - 由于使用逻辑外键，删除会话时需要在应用层手动删除关联的消息
   - 在 Repository 层的 `deleteChatSession` 方法中实现级联删除逻辑
   - `aiProviderId` 为必填字段，创建会话时必须提供有效的 AI Provider ID
   - 创建会话前需要验证 `aiProviderId` 的有效性（检查 Provider 是否存在）

2. **性能优化**
   - 对话列表分页加载
   - 消息列表按需加载
   - 使用索引优化查询性能

3. **错误处理**
   - 完善的错误处理和用户提示
   - 数据库操作失败时的回滚机制
   - 创建会话时验证 `aiProviderId` 的有效性，如果 Provider 不存在应返回明确的错误提示
   - 如果用户未选择 AI Provider，应提示用户先配置 AI Provider

4. **用户体验**
   - 加载状态提示
   - 操作反馈（成功/失败）
   - 流畅的切换动画

5. **代码质量**
   - 遵循现有代码风格
   - 保持代码简洁易懂
   - 注意模块化和复用
   - 最小化修改范围

6. **向后兼容**
   - 迁移现有内存中的会话数据（如果需要）
   - 保持现有 API 接口不变

## 十二、扩展功能（未来）

1. **对话搜索**
   - 根据关键词搜索对话标题
   - 搜索消息内容
   - 高级搜索（按时间范围、AI Provider 等）

2. **对话导出**
   - 导出为 Markdown
   - 导出为 JSON
   - 导出为 PDF

3. **对话导入**
   - 从文件导入对话
   - 批量导入

4. **对话分类**
   - 标签系统
   - 文件夹组织

5. **对话统计**
   - 消息数量统计
   - 对话时长统计
   - Token 使用统计（基于 Message 表的 `totalTokens` 字段）
   - 单条消息 Token 统计
   - 会话总 Token 统计

6. **对话分享**
   - 生成分享链接
   - 导出为图片

## 十三、技术细节

### 13.1 ID 生成

使用 Snowflake ID 生成器（项目中已有 `generateUUID` 函数），确保 ID 的唯一性和有序性。

### 13.2 时间戳处理

- 使用 `DateTime` 类型存储时间
- ChatSession 使用 `@default(now())` 和 `@updatedAt` 自动管理创建和更新时间
- Message 使用 `@default(now())` 自动管理创建时间（消息创建时自动设置）

### 13.3 内容存储

- 消息内容使用 `String` 类型存储
- 支持长文本（SQLite TEXT 类型无长度限制）
- 考虑未来支持富文本或 Markdown 格式

### 13.4 关联关系（逻辑外键）

**设计原则**：
- ChatSession 和 Message 使用逻辑外键，不在数据库层面定义物理外键约束
- `sessionId` 和 `aiProviderId` 仅作为普通字段存储，通过应用层维护关联关系
- 使用索引优化查询性能（`@@index([sessionId])` 和 `@@index([aiProviderId])`）

**级联删除实现**：
- 删除会话时，需要在应用层手动删除关联的消息
- 在 `deleteChatSession` 方法中使用 Prisma 事务确保原子性：
  ```typescript
  await prisma.$transaction(async (tx) => {
    // 先删除所有关联的消息
    await tx.message.deleteMany({ where: { sessionId: id } })
    // 再删除会话
    await tx.chatSession.delete({ where: { id } })
  })
  ```

**数据完整性**：
- 应用层需要验证 `sessionId` 和 `aiProviderId` 的有效性
- 查询时使用 `where` 条件进行关联查询
- `aiProviderId` 为必填字段，创建会话时必须提供有效的 AI Provider ID
- 删除 AI Provider 时，需要处理关联的会话（应用层可选择性处理：删除会话或提示用户）

