# AI 聊天功能设计方案

## 一、架构设计

### 1.1 整体架构

采用分层架构，实现关注点分离和可扩展性：

```
┌─────────────────────────────────────────┐
│         Renderer 层 (UI)                │
│  - 聊天界面组件                          │
│  - 状态管理 (zustand)                    │
│  - 用户交互                              │
└──────────────┬──────────────────────────┘
               │ IPC 通信
┌──────────────▼──────────────────────────┐
│         IPC 层 (通信桥梁)               │
│  - 定义 IPC 通道常量                     │
│  - 类型定义                              │
│  - Preload 暴露 API                     │
└──────────────┬──────────────────────────┘
               │ IPC 调用
┌──────────────▼──────────────────────────┐
│         Main 层 (Handler)               │
│  - AIHandler: 统一处理 AI 请求           │
│  - 请求路由和分发                        │
│  - 流式响应管理                          │
└──────────────┬──────────────────────────┘
               │ 调用
┌──────────────▼──────────────────────────┐
│         Provider 层 (AI 提供商)         │
│  - AIProvider 接口                      │
│  - OpenAIProvider (实现)                │
│  - 未来: AnthropicProvider, etc.        │
└─────────────────────────────────────────┘
```

### 1.2 设计模式

1. **策略模式 (Strategy Pattern)**
   - 每个 AI 提供商实现统一的 `AIProvider` 接口
   - 运行时根据配置选择不同的提供商

2. **工厂模式 (Factory Pattern)**
   - `AIProviderFactory` 根据配置创建对应的提供商实例

3. **适配器模式 (Adapter Pattern)**
   - 将不同 AI 提供商的 API 差异适配为统一接口

## 二、目录结构

```
src/
├── main/
│   ├── handlers/
│   │   ├── index.ts                    # 统一注册 handlers
│   │   └── ai-handler.ts               # AI 请求处理器
│   └── providers/                      # AI 提供商实现
│       ├── index.ts                    # Provider 工厂和接口
│       ├── base-provider.ts            # 基础 Provider 抽象类
│       └── openai-provider.ts          # OpenAI 实现
├── common/
│   └── constants/
│       └── ipc.ts                      # IPC 通道常量（扩展）
├── preload/
│   ├── index.ts                        # 暴露 API
│   └── types.ts                        # IPC 类型定义（扩展）
└── types/
    └── ai.ts                           # AI 相关类型定义
```

## 三、核心接口设计

### 3.1 AIProvider 接口

```typescript
interface AIProvider {
  // 流式聊天
  streamChat(
    messages: Message[],
    config: AIConfig,
    callbacks: {
      onChunk: (chunk: string) => void
      onDone: () => void
      onError: (error: Error) => void
    },
    abortSignal?: AbortSignal
  ): Promise<void>
  
  // 验证配置
  validateConfig(config: AIConfig): boolean
}
```

### 3.2 AIConfig 类型扩展

```typescript
interface AIConfig {
  provider: 'openai' | 'anthropic' | 'custom'  // 提供商类型
  apiKey: string                                // API Key
  baseURL?: string                              // 自定义 baseURL
  model: string                                 // 模型名称
  temperature?: number                          // 温度参数
  maxTokens?: number                            // 最大 token 数
  // OpenAI 特定配置
  openai?: {
    organization?: string
  }
  // 未来其他提供商的特定配置
}
```

### 3.3 IPC 通道定义

```typescript
export const IPC_CHANNELS = {
  // AI 模块
  ai: {
    // 请求流式聊天
    streamChat: 'ai:stream-chat',
    // 流式响应事件
    streamChunk: 'ai:stream-chunk',
    streamDone: 'ai:stream-done',
    streamError: 'ai:stream-error',
    // 取消请求
    cancelChat: 'ai:cancel-chat'
  }
} as const
```

### 3.4 IPC 类型定义

```typescript
interface AIIPC {
  streamChat: {
    request: {
      messages: Omit<Message, 'id' | 'timestamp'>[]
      config: AIConfig
    }
    response: IPCResponse<void>  // 流式响应通过事件发送
  }
  cancelChat: {
    request: { requestId: string }
    response: IPCResponse<void>
  }
}
```

## 四、实现流程

### 4.1 请求流程

```
1. 用户在 UI 输入消息
   ↓
2. Renderer 调用 IPC: ai:stream-chat
   ↓
3. Main Handler 接收请求
   ↓
4. Handler 根据 config.provider 选择 Provider
   ↓
5. Provider 调用 OpenAI SDK
   ↓
6. Provider 通过回调函数处理流式响应
   ↓
7. Handler 通过 IPC 事件发送数据块到 Renderer
   ↓
8. Renderer 更新 UI 显示流式内容
```

### 4.2 流式响应处理

- 使用 `event.sender.send()` 发送流式数据块
- 每个数据块通过 `ai:stream-chunk` 事件发送
- 完成时发送 `ai:stream-done` 事件
- 错误时发送 `ai:stream-error` 事件

### 4.3 取消机制

- 每个请求分配唯一 `requestId`
- 使用 `AbortController` 实现取消
- 通过 `ai:cancel-chat` IPC 通道取消请求

## 五、扩展性设计

### 5.1 添加新的 AI 提供商

1. 创建新的 Provider 类，实现 `AIProvider` 接口
2. 在 `AIProviderFactory` 中注册新 Provider
3. 在 `AIConfig.provider` 类型中添加新选项
4. 无需修改 Handler 和其他层代码

### 5.2 配置管理

- 使用 `electron-store` 持久化 AI 配置
- 支持多配置切换（未来功能）
- 配置验证在 Provider 层实现

## 六、依赖安装

需要安装 OpenAI 官方库：
```bash
pnpm add openai
```

## 七、实现步骤

1. ✅ 设计方案（当前步骤）
2. 安装依赖（openai）
3. 定义类型和接口
4. 实现 OpenAIProvider
5. 实现 AIHandler
6. 扩展 IPC 通道和类型
7. 更新 Preload
8. 改造 Renderer 层使用 IPC
9. 测试和优化

## 八、注意事项

1. **安全性**：API Key 存储在 electron-store，不暴露到 Renderer
2. **错误处理**：完善的错误处理和用户提示
3. **性能**：流式响应避免阻塞主进程
4. **可维护性**：清晰的代码结构和注释
5. **最小化修改**：尽量复用现有代码，最小化改动范围
