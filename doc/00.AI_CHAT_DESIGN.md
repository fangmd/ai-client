# AI 聊天功能设计方案

## 一、架构设计

### 1.1 整体架构

采用分层架构，实现关注点分离和可扩展性：

```
┌─────────────────────────────────────────┐
│         Renderer 层 (UI)                │
│  - 聊天界面组件 (Chat, ChatInput)        │
│  - 状态管理 (zustand - chatStore)       │
│  - 用户交互                              │
└──────────────┬──────────────────────────┘
               │ IPC 通信
┌──────────────▼──────────────────────────┐
│         IPC 层 (通信桥梁)               │
│  - 定义 IPC 通道常量                     │
│  - 类型定义                              │
│  - @electron-toolkit/preload            │
└──────────────┬──────────────────────────┘
               │ IPC 调用
┌──────────────▼──────────────────────────┐
│         Main 层 (Handler)               │
│  - AIHandler: 统一处理 AI 请求           │
│  - ChatSessionHandler: 会话管理          │
│  - MessageHandler: 消息管理              │
│  - 请求路由和分发                        │
│  - 流式响应管理                          │
└──────────────┬──────────────────────────┘
               │ 调用
┌──────────────▼──────────────────────────┐
│         Provider 层 (AI 提供商)         │
│  - AIProvider 接口                      │
│  - OpenAIProvider (已实现)              │
│  - 未来: AnthropicProvider, etc.        │
└──────────────┬──────────────────────────┘
               │ 调用
┌──────────────▼──────────────────────────┐
│         Repository 层 (数据持久化)      │
│  - Prisma ORM + SQLite                  │
│  - ChatSession Repository               │
│  - Message Repository                   │
│  - AIProvider Repository                │
└─────────────────────────────────────────┘
```

### 1.2 设计模式

1. **策略模式 (Strategy Pattern)**
   - 每个 AI 提供商实现统一的 `AIProvider` 接口
   - 运行时根据配置选择不同的提供商

2. **工厂模式 (Factory Pattern)**
   - `AIProviderFactory` 根据配置创建对应的提供商实例

3. **适配器模式 (Adapter Pattern)**
   - 将不同 AI 提供商的 API 差异适配为统一接口

4. **仓储模式 (Repository Pattern)**
   - 使用 Prisma 实现数据访问层
   - 封装数据库操作，提供统一的数据访问接口

## 二、目录结构

```
src/
├── main/
│   ├── common/
│   │   └── db/
│   │       └── prisma.ts              # Prisma 客户端
│   ├── handlers/
│   │   ├── index.ts                   # 统一注册 handlers
│   │   ├── ai-handler.ts              # AI 请求处理器
│   │   ├── ai-provider-handler.ts     # AI Provider 管理
│   │   ├── chat-session-handler.ts    # 会话管理
│   │   ├── message-handler.ts         # 消息管理
│   │   └── config-handler.ts          # 配置管理
│   ├── providers/                     # AI 提供商实现
│   │   ├── index.ts                   # Provider 工厂和接口
│   │   └── openai-provider.ts         # OpenAI 实现
│   ├── repository/                    # 数据访问层
│   │   ├── index.ts                   # 统一导出
│   │   ├── ai-provider.ts             # AI Provider 仓储
│   │   ├── chat-session.ts            # 会话仓储
│   │   ├── message.ts                 # 消息仓储
│   │   └── config.ts                  # 配置仓储
│   └── utils/
│       └── logger.ts                  # 日志工具
├── common/
│   ├── constants/
│   │   ├── index.ts                   # 常量导出
│   │   └── ipc.ts                     # IPC 通道常量
│   ├── request/                       # 请求相关
│   ├── response.ts                    # 响应封装
│   └── snowflake.ts                   # ID 生成器
├── preload/
│   └── index.ts                       # Preload 暴露 API
├── renderer/
│   └── src/
│       ├── hooks/
│       │   └── use-ai-chat.tsx        # AI 聊天 Hook
│       ├── stores/
│       │   └── chatStore.ts           # 聊天状态管理
│       ├── page/
│       │   └── chat.tsx               # 聊天页面
│       └── chat/
│           ├── chat-input.tsx         # 聊天输入组件
│           ├── message-item.tsx       # 消息展示组件
│           └── markdown-viewer/       # Markdown 渲染
├── types/
│   ├── index.ts                       # 类型导出
│   ├── chat-type.ts                   # 聊天相关类型
│   ├── ai-provider-type.ts            # AI Provider 类型
│   ├── config-type.ts                 # 配置类型
│   └── ipc-type.ts                    # IPC 类型
└── prisma/
    ├── schema.prisma                  # Prisma 数据模型
    └── migrations/                    # 数据库迁移
```

## 三、核心接口设计

### 3.1 AIProvider 接口

```typescript
interface AIProvider {
  // 流式聊天
  streamChat(
    messages: Omit<Message, 'id' | 'timestamp'>[],
    config: AIConfig,
    callbacks: {
      onChunk: (chunk: string) => void
      onDone: () => void
      onError: (error: Error) => void
    },
    abortSignal?: AbortSignal
  ): Promise<void>
  
  // 验证配置
  validateConfig(config: AIConfig): boolean
}
```

### 3.2 AIConfig 类型

```typescript
interface AIConfig {
  provider: 'openai' | 'anthropic' | 'custom'  // 提供商类型
  apiKey: string                                // API Key
  baseURL?: string                              // 自定义 baseURL
  model: string                                 // 模型名称
  temperature?: number                          // 温度参数
  maxTokens?: number                            // 最大 token 数
  // OpenAI 特定配置
  openai?: {
    organization?: string
  }
  // 未来其他提供商的特定配置
}
```

### 3.3 IPC 通道定义

```typescript
export const IPC_CHANNELS = {
  // AI 模块
  ai: {
    streamChat: 'ai:stream-chat',      // 请求流式聊天
    streamChunk: 'ai:stream-chunk',    // 流式响应事件
    streamDone: 'ai:stream-done',      // 完成事件
    streamError: 'ai:stream-error',    // 错误事件
    cancelChat: 'ai:cancel-chat'       // 取消请求
  },
  // AI Provider 模块
  aiProvider: {
    create: 'ai-provider:create',
    list: 'ai-provider:list',
    getDefault: 'ai-provider:get-default',
    update: 'ai-provider:update',
    delete: 'ai-provider:delete',
    setDefault: 'ai-provider:set-default'
  },
  // Chat Session 模块
  chatSession: {
    create: 'chat-session:create',
    list: 'chat-session:list',
    get: 'chat-session:get',
    update: 'chat-session:update',
    delete: 'chat-session:delete'
  },
  // Message 模块
  message: {
    create: 'message:create',
    update: 'message:update',
    list: 'message:list',
    append: 'message:append'
  },
  // Config 模块
  config: {
    get: 'config:get',
    getAll: 'config:get-all',
    set: 'config:set',
    delete: 'config:delete'
  }
} as const
```

### 3.4 Message 类型

```typescript
// 前端消息类型
interface Message {
  id: bigint
  role: 'user' | 'assistant' | 'system'
  content: string
  timestamp: number
  status?: 'sending' | 'done' | 'error'
}

// 数据库消息类型
type DbMessage = {
  id: bigint
  sessionId: bigint
  role: string
  content: string
  status: 'sent' | 'pending' | 'error' | null
  totalTokens: number | null
  createdAt: Date
}
```

## 四、实现流程

### 4.1 请求流程

```
1. 用户在 UI 输入消息
   ↓
2. useAIChat Hook 处理发送逻辑
   ↓
3. 如果无会话，先创建会话 (IPC: chat-session:create)
   ↓
4. 创建用户消息到数据库 (IPC: message:create)
   ↓
5. 创建空的助手消息（pending 状态）
   ↓
6. Renderer 调用 IPC: ai:stream-chat
   ↓
7. AIHandler 接收请求
   ↓
8. Handler 根据 config.provider 选择 Provider
   ↓
9. OpenAIProvider 调用 OpenAI SDK
   ↓
10. Provider 通过回调函数处理流式响应
    ↓
11. Handler 通过 IPC 事件发送数据块到 Renderer
    ↓
12. Renderer 实时更新 UI（本地状态）
    ↓
13. 完成后更新数据库中的消息
```

### 4.2 流式响应处理

- 使用 `ipcMain.on` 监听流式聊天请求
- 使用 `event.sender.send()` 发送流式数据块
- 每个数据块通过 `ai:stream-chunk` 事件发送
- 完成时发送 `ai:stream-done` 事件
- 错误时发送 `ai:stream-error` 事件
- 流式期间先更新本地状态，完成后同步到数据库

### 4.3 取消机制

- 每个请求分配唯一 `requestId`
- 使用 `AbortController` 实现取消
- 通过 `ai:cancel-chat` IPC 通道取消请求
- 使用 `activeRequests` Map 管理活跃请求

### 4.4 数据持久化

- 使用 Prisma ORM 管理数据库
- SQLite 作为本地数据库存储
- 会话和消息自动持久化
- 支持会话列表和历史消息加载

## 五、扩展性设计

### 5.1 添加新的 AI 提供商

1. 创建新的 Provider 类，实现 `AIProvider` 接口
2. 在 `AIProviderFactory.create()` 中注册新 Provider
3. 在 `AIConfig.provider` 类型中添加新选项
4. 无需修改 Handler 和其他层代码

### 5.2 配置管理

- 使用 Prisma + SQLite 持久化 AI Provider 配置
- 支持多 AI Provider 配置管理
- 支持设置默认 Provider
- 配置验证在 Provider 层实现

## 六、实现步骤

1. ✅ 设计方案
2. ✅ 安装依赖（openai, prisma, zustand）
3. ✅ 定义类型和接口 (`src/types/`)
4. ✅ 实现 AIProvider 接口和工厂 (`src/main/providers/index.ts`)
5. ✅ 实现 OpenAIProvider (`src/main/providers/openai-provider.ts`)
6. ✅ 实现 AIHandler (`src/main/handlers/ai-handler.ts`)
7. ✅ 定义 IPC 通道常量 (`src/common/constants/ipc.ts`)
8. ✅ 配置 Preload (`@electron-toolkit/preload`)
9. ✅ 实现数据持久化层 (Prisma + Repository)
10. ✅ 实现 ChatSessionHandler 和 MessageHandler
11. ✅ 实现 useAIChat Hook (`src/renderer/src/hooks/use-ai-chat.tsx`)
12. ✅ 实现 chatStore (Zustand Store)
13. ✅ 实现聊天 UI 组件 (Chat, ChatInput, MessageItem)
14. ✅ 集成测试和优化

## 七、注意事项

1. **安全性**：API Key 存储在数据库，不暴露到 Renderer
2. **错误处理**：完善的错误处理和用户提示
3. **性能**：
   - 流式响应避免阻塞主进程
   - 流式期间使用本地状态，减少数据库操作
4. **可维护性**：清晰的代码结构和注释
5. **最小化修改**：尽量复用现有代码，最小化改动范围
6. **数据一致性**：流式响应完成后才写入数据库，保证数据完整性

## 八、核心模块说明

### 9.1 AIHandler

负责处理 AI 相关的 IPC 请求，管理流式聊天的生命周期：

- 接收流式聊天请求
- 创建和管理 AbortController
- 路由到对应的 Provider
- 转发流式响应事件

### 9.2 OpenAIProvider

OpenAI API 的具体实现：

- 配置验证
- 创建 OpenAI 客户端
- 处理流式响应
- 错误处理和日志记录

### 9.3 useAIChat Hook

Renderer 层的聊天逻辑封装：

- 管理请求生命周期
- 监听 IPC 事件
- 协调本地状态和数据库同步
- 提供取消和重置功能

### 9.4 chatStore

Zustand 状态管理：

- 会话和消息的本地状态
- 与数据库同步的 Actions
- 纯本地操作（用于流式响应实时更新）
- 流式消息控制
