---
description: Electron IPC 调用架构规范，定义三层架构（Preload/Main/Renderer）的通信标准，包括通道命名、响应格式、Handler 实现、文件命名等规范，确保 IPC 调用的类型安全和代码一致性
globs: 
alwaysApply: true
---
# IPC 调用架构规范

## 架构原则

本项目使用三层 IPC 架构：
- **Preload 层** (`src/preload/`): 暴露 Electron API 和通道常量
- **Main 层** (`src/main/handlers/`): Handler 类处理 IPC 请求
- **Renderer 层**: 直接使用 `window.electron.ipcRenderer`

## 核心规范

### 1. 通道命名
- 格式：`模块名:操作名` (kebab-case)
- 位置：`src/common/constants/ipc.ts`
- 必须使用 `IPC_CHANNELS` 常量，禁止硬编码字符串
- 示例：`IPC_CHANNELS.test.ping` 而不是 `'test:ping'`

### 2. 响应格式
- 统一使用 `IPCResponse<T>` 接口
- 格式：`{ code: number, data?: T, msg: string }`
- `code: 0` 表示成功，`code: -1` 表示失败
- 类型定义位置：`src/preload/types.ts`
- **必须使用工具函数构建响应**：
  - `responseSuccess<T>(data?, msg?)` - 创建成功响应
  - `responseError(error, code?)` - 创建错误响应
  - 工具函数位置：`src/common/response.ts`

### 3. Handler 实现
- 文件命名：`xxx-handler.ts` (kebab-case)
- 使用静态类方法：`static register()` 和 `static unregister()`
- 必须使用 try-catch 包裹，返回标准 `IPCResponse` 格式
- 必须从 `IPC_CHANNELS` 导入通道常量
- **必须使用工具函数构建响应**：
  - 成功响应：`return responseSuccess(data)` 或 `return responseSuccess(data, 'custom message')`
  - 错误响应：`return responseError(error)` 或 `return responseError('error message', customCode)`
- **优先使用 `ipcMain.handle` 直接返回结果**：如果函数能直接返回结果，使用 `ipcMain.handle` 并直接 `return`，不要使用 `event.reply`
- **流式/事件式通信才使用 `ipcMain.on`**：只有在需要流式传输、多次事件推送或需要主动推送消息时，才使用 `ipcMain.on` + `event.reply`

### 4. Handler 注册
- 统一在 `src/main/handlers/index.ts` 中注册
- 使用 `registerHandlers()` 函数统一注册所有 handlers

### 5. Renderer 调用
- **优先使用 `ipcRenderer.invoke`**：如果主进程函数能直接返回结果，使用 `window.electron.ipcRenderer.invoke()` 获取 Promise 结果
- **流式/事件式通信才使用 `send` + `on`**：只有在需要流式传输、多次事件推送或需要主动推送消息时，才使用 `send()` + `on()` 的方式
- 必须从 `@/common/constants/ipc` 导入 `IPC_CHANNELS` 常量获取通道名称
- 必须导入 `IPCResponse` 类型
- 检查 `response.code === SUCCESS_CODE` 判断成功
- 使用 `invoke` 时必须调用 `unsubscribe()` 取消监听（如果使用了 `on`）
- 禁止硬编码通道名称字符串

### 6. 文件命名
- 统一使用 kebab-case：`xxx-handler.ts`
- 禁止使用 camelCase 或 snake_case

## 代码示例

### Handler 实现模板（推荐：直接返回结果）

**优先使用 `ipcMain.handle` 直接返回结果**：

```typescript
import { ipcMain } from 'electron'
import { IPC_CHANNELS } from '../../common/constants'
import { responseSuccess, responseError } from '../../common/response'

export class XxxHandler {
  static register(): void {
    // 使用 handle 直接返回结果
    ipcMain.handle(IPC_CHANNELS.xxx.action, async (_event, data: RequestData) => {
      try {
        const result = await someAsyncOperation(data)
        return responseSuccess(result)
      } catch (error) {
        return responseError(error)
      }
    })
  }

  static unregister(): void {
    ipcMain.removeHandler(IPC_CHANNELS.xxx.action)
  }
}
```

### Renderer 调用模板（推荐：使用 invoke）

**优先使用 `ipcRenderer.invoke` 获取 Promise 结果**：

```typescript
import type { IPCResponse } from '@/preload/types'
import { IPC_CHANNELS, SUCCESS_CODE } from '@/common/constants/ipc'

// 使用 invoke 直接获取结果
const response = await window.electron.ipcRenderer.invoke(
  IPC_CHANNELS.xxx.action,
  requestData
) as IPCResponse<DataType>

if (response.code === SUCCESS_CODE) {
  // 成功处理
  console.log(response.data)
} else {
  // 错误处理
  console.error(response.msg)
}
```

### Handler 实现模板（流式/事件式通信）

**只有在需要流式传输或多次事件推送时才使用 `ipcMain.on`**：

```typescript
import { ipcMain } from 'electron'
import { IPC_CHANNELS } from '../../common/constants'
import { responseSuccess, responseError } from '../../common/response'

export class StreamHandler {
  static register(): void {
    // 流式传输示例
    ipcMain.on(IPC_CHANNELS.xxx.streamStart, async (event, data) => {
      try {
        // 流式发送多个数据块
        for (const chunk of streamData) {
          event.sender.send(IPC_CHANNELS.xxx.streamChunk, { chunk })
        }
        event.sender.send(IPC_CHANNELS.xxx.streamDone, {})
      } catch (error) {
        event.sender.send(IPC_CHANNELS.xxx.streamError, responseError(error))
      }
    })

    // 需要回复成功/失败的事件式通信
    ipcMain.on(IPC_CHANNELS.xxx.action, (event, data) => {
      try {
        // 处理逻辑
        event.reply(IPC_CHANNELS.xxx.actionReply, responseSuccess(result))
      } catch (error) {
        event.reply(IPC_CHANNELS.xxx.actionReply, responseError(error))
      }
    })
  }

  static unregister(): void {
    ipcMain.removeAllListeners(IPC_CHANNELS.xxx.streamStart)
    ipcMain.removeAllListeners(IPC_CHANNELS.xxx.action)
  }
}
```

### Renderer 调用模板（流式/事件式通信）

**只有在需要流式传输或多次事件推送时才使用 `send` + `on`**：

```typescript
import type { IPCResponse } from '@/preload/types'
import { IPC_CHANNELS, SUCCESS_CODE } from '@/common/constants/ipc'

// 发送流式请求
window.electron.ipcRenderer.send(IPC_CHANNELS.xxx.streamStart, requestData)

// 监听流式数据块
const unsubscribeChunk = window.electron.ipcRenderer.on(
  IPC_CHANNELS.xxx.streamChunk,
  (_event, data: { chunk: string }) => {
    // 处理数据块
    console.log(data.chunk)
  }
)

// 监听完成事件
const unsubscribeDone = window.electron.ipcRenderer.on(
  IPC_CHANNELS.xxx.streamDone,
  () => {
    // 清理监听器
    unsubscribeChunk()
    unsubscribeDone()
  }
)
```

## 新增 IPC 功能步骤

1. 在 `src/common/constants/ipc.ts` 添加通道常量
2. 在 `src/preload/types.ts` 添加类型接口
3. 创建 `src/main/handlers/xxx-handler.ts` 实现 Handler
   - **优先使用 `ipcMain.handle`**：如果函数能直接返回结果
   - **流式/事件式才使用 `ipcMain.on`**：如果需要流式传输或多次事件推送
4. 在 `src/main/handlers/index.ts` 注册 Handler
5. 在 renderer 中使用 `window.electron.ipcRenderer` 调用
   - **优先使用 `invoke`**：如果主进程能直接返回结果
   - **流式/事件式才使用 `send` + `on`**：如果需要流式传输或多次事件推送

## 选择指南

### 何时使用 `ipcMain.handle` + `ipcRenderer.invoke`（推荐）

✅ 查询操作（获取数据）
✅ 创建/更新/删除操作（返回操作结果）
✅ 任何能直接返回单一结果的同步或异步操作
✅ 需要等待结果后再继续执行的场景

### 何时使用 `ipcMain.on` + `ipcRenderer.send` + `on`

✅ 流式数据传输（如 AI 聊天流式响应）
✅ 需要多次推送事件的场景（如进度更新）
✅ 主进程主动推送消息给渲染进程
✅ 不需要等待结果的单向通信

## 禁止事项

- ❌ 禁止硬编码通道名称字符串
- ❌ 禁止直接使用 `window.electron.ipcRenderer.send('test:ping')`
- ❌ 禁止在 Handler 中不使用 try-catch
- ❌ 禁止返回非标准响应格式
- ❌ **禁止手动构建 `IPCResponse` 对象**：必须使用 `responseSuccess()` 和 `responseError()` 工具函数
- ❌ 禁止使用 camelCase 或 snake_case 命名文件
- ❌ 禁止使用 `window.api.*` 相关 API，应直接使用 `window.electron.ipcRenderer` 进行 IPC 通信，并通过导入 `IPC_CHANNELS` 获取通道名称
- ❌ **禁止在能直接返回结果时使用 `ipcMain.on` + `event.reply`**：如果函数能直接返回结果，必须使用 `ipcMain.handle` 并直接 `return`，不要使用监听方式
- ❌ **禁止在能直接返回结果时使用 `send` + `on`**：如果主进程能直接返回结果，必须使用 `ipcRenderer.invoke` 获取 Promise，不要使用 `send` + `on` 的方式
